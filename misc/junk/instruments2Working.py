#  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
#  SCAMP (Suite for Computer-Assisted Music in Python)                                           #
#  Copyright Â© 2020 Marc Evanstein <marc@marcevanstein.com>.                                     #
#                                                                                                #
#  This program is free software: you can redistribute it and/or modify it under the terms of    #
#  the GNU General Public License as published by the Free Software Foundation, either version   #
#  3 of the License, or (at your option) any later version.                                      #
#                                                                                                #
#  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;     #
#  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     #
#  See the GNU General Public License for more details.                                          #
#                                                                                                #
#  You should have received a copy of the GNU General Public License along with this program.    #
#  If not, see <http://www.gnu.org/licenses/>.                                                   #
#  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #

import itertools
from .spelling import SpellingPolicy
from .note_properties import NotePropertiesDictionary
from clockblocks import *
import logging
import time


class PlaybackImplementer:

    _note_id_generator = itertools.count()

    def __init__(self):
        self._active_note_ids = []
        self._note_info_by_id = {}

    """
    ------------------------w------------ Playback Methods to be Overridden ----------------------------------------
    Mix-ins providing extra playback functionality should override these methods starting with:
        note_id = super().start_note(pitch, volume, properties)
    And ending with:
        return note_id
    This way, the note_id generated by the base class is passed up the chain to each piece of playback machinery.
    """

    def _do_start_note(self, pitch, volume, properties):
        # does the actual sonic implementation of starting a note and creates an id for it
        note_id = next(PlaybackImplementer._note_id_generator)
        self._active_note_ids.append(note_id)
        self._note_info_by_id[note_id] = {
            "start_time": TimeStamp(),
            "parameter_start_values": {
                "pitch": pitch,
                "volume": volume,
            },
            "parameter_values": {
                "pitch": pitch,
                "volume": volume,
            },
            "current_animation_process": {
                "pitch": None,
                "volume": None,
            },
            "parameter_change_segments": {},
            "properties": properties,
        }
        return note_id

    def _do_end_note(self, note_id):
        # Does the actual sonic implementation of ending a the note with the given id
        self._active_note_ids.remove(note_id)
        return note_id

    def _do_change_note_pitch(self, note_id, new_pitch):
        # Changes the pitch of the note with the given id
        self._note_info_by_id[note_id]["parameter_values"]["pitch"] = new_pitch
        print("changing pitch to", new_pitch)
        return note_id

    def _do_change_note_volume(self, note_id, new_volume):
        # Changes the expression of the note with the given id
        self._note_info_by_id[note_id]["parameter_values"]["volume"] = new_volume
        print("changing volume to", new_volume)
        return note_id

    def _do_change_note_parameter(self, note_id, parameter_name, new_value):
        # Changes an arbitrary parameter of the note, for instance when controlling an electronic instrument over osc
        self._note_info_by_id[note_id]["parameter_values"][parameter_name] = new_value
        print("changing parameter", parameter_name, "to", new_value)
        return note_id


class ParameterChangeSegment(EnvelopeSegment):

    def __init__(self, parameter_change_function, start_value, target_value, transition_length, transition_curve_shape,
                 clock, time_increment=0.01):
        super().__init__(0, transition_length, start_value, target_value, transition_curve_shape)
        self.do_change_parameter = parameter_change_function
        self.clock = clock
        self.time_increment = time_increment
        self.running = False
        self.start_time_stamp = None
        self.end_time_stamp = None
        self._synchronized_child_clock = None

    def run(self, blocking=False):

        if self.duration == 0:
            self._run_instantaneous()
            return

        self.start_time_stamp = TimeStamp(self.clock)
        self.running = True

        def _animation_function():
            # does the intermediate changing of values; since it's sleeping in small time increments, we fork it
            # as unsynchronized parallel process so that it doesn't gum up the clocks with the overhead of
            # waking and sleeping rapidly
            beats_passed = 0

            while beats_passed < self.duration and self.running:
                start = time.time()
                if beats_passed > 0:  # no need to change the parameter the first time
                    self.do_change_parameter(self.value_at(beats_passed))
                time.sleep(self.time_increment)
                beats_passed += (time.time() - start) * self.clock.absolute_rate()

        def _synchronized_function():
            wait(self.duration)

            # we only get here if it wasn't aborted while running, since that will call kill on the child clock
            self.running = False
            self.end_time_stamp = TimeStamp(self.clock)
            self.do_change_parameter(self.end_level)

        # waits in a synchronized fashion so that it can save an accurate time stamp at the end
        self.clock.fork_unsynchronized(_animation_function)
        if blocking:
            self._synchronized_child_clock = current_clock()
            _synchronized_function()
        else:
            self._synchronized_child_clock = self.clock.fork(_synchronized_function)

    def _run_instantaneous(self):
        self.start_time_stamp = self.end_time_stamp = TimeStamp(self.clock)
        self.do_change_parameter(self.end_level)

    def abort_if_running(self):
        if self.running:
            self.end_time_stamp = TimeStamp(self.clock)
            self._synchronized_child_clock.kill()
            how_far_we_got = self.end_time_stamp.beat_in_clock(self.clock) - \
                             self.start_time_stamp.beat_in_clock(self.clock)
            self.split_at(how_far_we_got)
            self.do_change_parameter(self.end_level)  # set it to where we should be at this point
        self.running = False

    def completed(self):
        # it's not running, but because it finished, not because it never started
        return not self.running and self.end_time_stamp is not None

    def __repr__(self):
        return "ParameterChangeSegment[{}, {}, {}, {}, {}]".format(
            self.start_time_stamp, self.end_time_stamp, self.start_level, self.end_level, self.curve_shape
        )


class ScampInstrument(PlaybackImplementer):

    _note_id_generator = itertools.count()

    def __init__(self, name, ensemble=None):
        """
        Base instrument class.
        """
        self.name = name
        self.name_count = ensemble.get_part_name_count(self.name) if ensemble is not None else 0

        self.ensemble = ensemble
        self._transcribers_to_notify = []

        # A policy for spelling notes used as the default for this instrument. Overrides any broader defaults.
        self._default_spelling_policy = None

        super().__init__()

    """
    ------------------------------------------ "Meta" Playback Methods ------------------------------------------
    Playback methods that make use of the specific implementations defined and overridden above
    """

    def play_note(self, pitch, volume, length, properties=None):
        pass

    def start_note(self, pitch, volume, properties=None):
        properties = self._standardize_properties(properties)
        return self._do_start_note(pitch, volume, properties)

    def _standardize_properties(self, raw_properties) -> NotePropertiesDictionary:
        """
        Turns the properties given into the standard form of a NotePropertiesDictionary
        :param raw_properties: can be None, a string, a list, or a dict
        :return: a NotePropertiesDictionary
        """
        properties = NotePropertiesDictionary.from_unknown_format(raw_properties) \
            if not isinstance(raw_properties, NotePropertiesDictionary) else raw_properties

        # resolve the spelling policy based on defaults (local first, then more global)
        if properties["spelling_policy"] is None:
            # if the note doesn't say how to be spelled, check the instrument
            if self.default_spelling_policy is not None:
                properties.spelling_policy = self.default_spelling_policy
            # if the instrument doesn't have a default spelling policy check the host (probably a Session)
            elif self.ensemble is not None and hasattr(self.ensemble, "default_spelling_property") and \
                    self.ensemble.default_spelling_policy is not None:
                properties.spelling_policy = self.default_spelling_policy
            # if the host doesn't have a default, then don't do anything and it will fall back to playback_settings
        return properties

    def change_note_parameter(self, note_id, param_name, target_value, transition_length=0,
                              transition_curve_shape=0, clock="auto"):
        note_info = self._note_info_by_id[note_id]

        # which function do we use to actually carry out the change of parameter? Pitch and volume are special.
        if param_name == "pitch":
            def parameter_change_function(value): self._do_change_note_pitch(note_id, value)
        elif param_name == "volume":
            def parameter_change_function(value): self._do_change_note_volume(note_id, value)
        else:
            def parameter_change_function(value): self._do_change_note_parameter(note_id, param_name, value)

        clock = current_clock() if clock == "auto" else clock
        if clock is None:
            clock = Clock()

        assert param_name in note_info["parameter_values"], \
            "Cannot change parameter {}, as it was undefined at note start.".format(param_name)

        if param_name in note_info["parameter_change_segments"]:
            segments_list = note_info["parameter_change_segments"][param_name]
        else:
            segments_list = note_info["parameter_change_segments"][param_name] = []

        # TODO: ADD IN TIME INCREMENT CALCULATION

        if len(segments_list) > 0:
            segments_list[-1].abort_if_running()

        if hasattr(target_value, "__len__"):
            # assume linear segments unless otherwise specified
            transition_curve_shape = [0] * len(target_value) if transition_curve_shape == 0 else transition_curve_shape
            assert hasattr(transition_length, "__len__") and hasattr(transition_curve_shape, "__len__")
            assert len(target_value) == len(transition_length) == len(transition_curve_shape), \
                "The list of target values must be accompanied by a equal length list of transition lengths and shapes."

            def do_sequence(child_clock):
                for target, length, shape in zip(target_value, transition_length, transition_curve_shape):
                    parameter_change_segment = ParameterChangeSegment(
                        parameter_change_function, note_info["parameter_values"][param_name], target,
                        length, shape, child_clock)
                    segments_list.append(parameter_change_segment)
                    parameter_change_segment.run(blocking=True)

            clock.fork(do_sequence)
        else:
            parameter_change_segment = ParameterChangeSegment(
                parameter_change_function, note_info["parameter_values"][param_name], target_value, transition_length,
                transition_curve_shape, clock)
            segments_list.append(parameter_change_segment)
            parameter_change_segment.run(blocking=False)

    @staticmethod
    def _get_good_pitch_bend_temporal_resolution(pitch_envelope_segment):
        """
        Returns a reasonable temporal resolution
        """
        max_cents_per_second = pitch_envelope_segment.max_absolute_slope() * 100
        # cents / update * updates / sec = cents / sec   =>  updates_freq = cents_per_second / cents_per_update
        # we'll aim for 4 cents per update, since some say the JND is 5-6 cents
        update_freq = max_cents_per_second / 4.0
        return 1 / update_freq

    @staticmethod
    def get_good_volume_temporal_resolution(volume_envelope_segment):
        """
        Returns a reasonable temporal resolution
        """
        max_volume_per_second = volume_envelope_segment.max_absolute_slope()
        # based on the idea that for midi volumes, it's quantized from 0 to 127, so there's not much point in updating
        # in between those quantization levels. It's a decent enough rule even if not using midi output.
        update_freq = max_volume_per_second * 127
        return 1 / update_freq

    def change_note_volume(self, note_id, volume_target, transition_length=0):
        # can take an envelope and implement an animation!
        # calls self._do_change_note_volume(note_id)
        pass

    def end_note(self, note_id=None):
        """
        Ends the note with the given note id. If none is specified, it ends the note we started longest ago.
        Note that this only applies to notes started in an open-ended way with 'start_note', notes created
        using play_note have their lifecycle controlled automatically.
        """
        if note_id is not None:
            # as specific note_id has been given, so it had better belong to a currently playing note!
            if note_id not in self._active_note_ids:
                logging.warning("Tried to end a note that was never started!")
                return
            self._active_note_ids.remove(note_id)
        elif len(self._active_note_ids) > 0:
            # no specific id was given, so end the oldest note
            note_id = self._active_note_ids.pop(0)
        else:
            logging.warning("Tried to end a note that was never started!")
            return

        self._do_end_note(note_id)
        del self._note_info_by_id[note_id]

    def end_all_notes(self):
        """
        Ends all notes that have been manually started with 'start_note'
        """
        while len(self._active_note_ids) > 0:
            self.end_note()

    def num_notes_playing(self):
        """
        Returns the number of notes currently playing that were manually started with 'start_note'
        """
        return len(self._active_note_ids)

    """
    ------------------------------------------------- Other -----------------------------------------------------
    """

    @property
    def default_spelling_policy(self):
        return self._default_spelling_policy

    @default_spelling_policy.setter
    def default_spelling_policy(self, value):
        if value is None or isinstance(value, SpellingPolicy):
            self._default_spelling_policy = value
        elif isinstance(value, str):
            self._default_spelling_policy = SpellingPolicy.from_string(value)
        else:
            raise ValueError("Spelling policy not understood.")


class MidiPlayback(PlaybackImplementer):
    # MAKE IT POSSIBLE TO SET A FLAG THAT ELIMINATES THE POSSIBILITY OF BENDING PITCH AND THUS CONSERVES CHANNELS
    pass


# class ScampInstrument(PlaybackMethod, SavesToJSON):
#
#     def __init__(self, host=None, name=None):
#         """
#         ScampInstrument inherits from PlaybackMethod, with the default
#         :param host: The Session or Ensemble that this instrument acts within
#         :param name: The name of this instrument (used later in labeling parts in output)
#         """
#         self.name = name
#         self.name_count = None  # if an ensemble
#         self.host_ensemble = None
#
#         if host is not None:
#             self.set_host(host)
#
#         # A policy for spelling notes used as the default for this instrument. Overrides the session default.
#         self._default_spelling_policy = None
#
#         # used to identify instruments uniquely, even if they're given the same name
#         self._notes_started = []   # each entry goes (note_id, pitch, volume, start_time, variant_dictionary)
#         self._performance_part = None
#
#     def set_host(self, host):
#         from .session import Session
#         from .ensemble import Ensemble
#         assert isinstance(host, (Session, Ensemble)), "ScampInstrument must be hosted by Ensemble or Session"
#         if isinstance(host, Session):
#             self.host_ensemble = host.ensemble
#         else:
#             self.host_ensemble = host
#         self.name_count = self.host_ensemble.get_part_name_count(self.name)
#
#     def time(self):
#         if self.host_ensemble is not None and self.host_ensemble.host_session is not None:
#             return self.host_ensemble.host_session.time()
#         else:
#             return time.time()
#
#
#     # ------------------ Methods to be implemented by subclasses ------------------
#
#     def _do_start_note(self, pitch, volume, properties):
#         # Does the actual sonic implementation of starting a note
#         # should return the note_id, which is used to keep track of the note
#         pass
#
#     def _do_end_note(self, note_id):
#         # Does the actual sonic implementation of ending a the note with the given id
#         pass
#
#     def change_note_pitch(self, note_id, new_pitch):
#         # Changes the pitch of the note with the given id
#         pass
#
#     def change_note_volume(self, note_id, new_volume):
#         # Changes the expression of the note with the given id
#         pass
#
#     def to_json(self):
#         return {
#             "type": "ScampInstrument",
#             "name": self.name,
#         }
#
#     # -------------- Reconstruct from JSON (doesn't need subclass reimplementation) ---------------
#
#     @staticmethod
#     def from_json(json_dict, host_ensemble=None):
#         # the 'type' argument of the json_dict tells us which kind of ScampInstrument constructor to use
#         type_to_create = None
#         for instrument_type in ScampInstrument.__subclasses__():
#             if json_dict["type"] == instrument_type.__name__:
#                 type_to_create = instrument_type
#                 break
#         if type_to_create is None:
#             raise ValueError("Trying to reconstruct instrument of type {}, "
#                              "but that type is not defined.".format(json_dict["type"]))
#         kwargs = dict(json_dict)
#         del kwargs["type"]
#         return type_to_create(host_ensemble, **kwargs)
#
#     # ------------------------- "Private" Playback Methods -----------------------
#
#     def _convert_properties_to_dictionary(self, raw_properties):
#         properties = NotePropertiesDictionary.from_unknown_format(raw_properties) \
#             if not isinstance(raw_properties, NotePropertiesDictionary) else raw_properties
#         if properties["spelling_policy"] is None:
#             if self.default_spelling_policy is not None:
#                 properties.spelling_policy = self.default_spelling_policy
#             elif self.host_ensemble is not None and self.host_ensemble.host_session is not None \
#                     and self.host_ensemble.host_session.default_spelling_policy is not None:
#                 properties.spelling_policy = self.host_ensemble.host_session.default_spelling_policy
#         return properties
#
#     def _do_play_note(self, pitch, volume, length, properties, clock=None):
#         # Does the actual sonic implementation of playing a note; used as a thread by the public method "play_note"
#         note_start_time = time.time()
#         # convert lists to Envelopes
#         is_animating_volume = isinstance(volume, Envelope)
#         is_animating_pitch = isinstance(pitch, Envelope)
#         # the starting volume (velocity) of the note needs to be as loud as the note is ever going to get
#         start_volume = volume.max_level() if isinstance(volume, Envelope) else volume
#         # the starting pitch should just be whatever it is
#         start_pitch = pitch.value_at(0) if isinstance(pitch, Envelope) else pitch
#
#         note_id = self._do_start_note(start_pitch, start_volume, properties)
#         if is_animating_volume or is_animating_pitch:
#             temporal_resolution = float("inf")
#             if is_animating_volume:
#                 volume_curve = volume.normalize_to_duration(length, False)
#                 temporal_resolution = min(temporal_resolution,
#                                           ScampInstrument.get_good_volume_temporal_resolution(volume_curve))
#             if is_animating_pitch:
#                 pitch_curve = pitch.normalize_to_duration(length, False)
#                 temporal_resolution = min(temporal_resolution,
#                                           ScampInstrument.get_good_pitch_bend_temporal_resolution(pitch_curve))
#             temporal_resolution = max(temporal_resolution, 0.01)  # faster than this is wasteful, doesn't seem to help
#
#             def animate_pitch_and_volume():
#                 while note_start_time is not None:
#                     try:
#                         # Sometimes do_play_note ends and start_time gets set to None in the middle of
#                         # the while loop, leading to a TypeError when we do time.time() - note_start_time
#                         # this catches that possibility
#                         if is_animating_volume:
#                             # note that, since change_note_volume is affecting expression values, we need to send it
#                             # the proportion of the start_volume rather than the absolute volume
#                             self.change_note_volume(note_id,
#                                                     volume_curve.value_at(time.time() - note_start_time) / start_volume)
#                         if is_animating_pitch:
#                             self.change_note_pitch(note_id, pitch_curve.value_at(time.time() - note_start_time))
#                     except TypeError:
#                         break
#
#                     time.sleep(temporal_resolution)
#
#             if temporal_resolution < length:  # catches the case of a static curve with infinite temporal_resolution
#                 if clock is not None:
#                     clock.fork_unsynchronized(process_function=animate_pitch_and_volume)
#                 else:
#                     threading.Thread(target=animate_pitch_and_volume, daemon=True).start()
#
#         time.sleep(length)
#         # cut off any pitch or volume animation thread by setting the start_time to None
#         note_start_time = None
#
#         self._do_end_note(note_id)
#
#     @staticmethod
#     def get_good_pitch_bend_temporal_resolution(pitch_envelope):
#         """
#         Returns a reasonable temporal resolution
#         :type pitch_envelope: Envelope
#         """
#         max_cents_per_second = pitch_envelope.max_absolute_slope() * 100
#         # cents / update * updates / sec = cents / sec   =>  updates_freq = cents_per_second / cents_per_update
#         # we'll aim for 4 cents per update, since some say the JND is 5-6 cents
#         update_freq = max_cents_per_second / 4.0
#         return 1 / update_freq
#
#     @staticmethod
#     def get_good_volume_temporal_resolution(volume_envelope):
#         """
#         Returns a reasonable temporal resolution
#         :type volume_envelope: Envelope
#         """
#         max_volume_per_second = volume_envelope.max_absolute_slope()
#         # no point in updating faster than the number of ticks per second
#         update_freq = max_volume_per_second * 127
#         return 1 / update_freq
#
#     # ------------------------- "Public" Playback Methods -------------------------
#
#     def play_note(self, pitch, volume, length, properties=None, blocking=True, clock=None):
#         """
#         Play a note
#         :param pitch: The midi pitch of the note. Can be floating-point, can be a list or Envelope.
#         :param volume: The volume, in a normalized range 0 to 1. Can be a list or Envelope.
#         :param length: The length of the note with respect to the clock used (seconds if no clock is used).
#         :param properties: A dictionary of properties about this note
#         :param blocking: blocks the current thread until done playing
#         :param clock: The clock within which this note is played. If none, we check if a clock has been defined on this
#         thread by setting threading.current_thread().__clock__ and use that. If no clocks at all, uses seconds.
#         :return: None
#         """
#
#         if clock is None and hasattr(threading.current_thread(), "__clock__"):
#             clock = threading.current_thread().__clock__
#
#         properties = self._convert_properties_to_dictionary(properties)
#
#         volume = Envelope.from_list(volume) if hasattr(volume, "__len__") else volume
#         pitch = Envelope.from_list(pitch) if hasattr(pitch, "__len__") else pitch
#
#         # record the note in the hosting session, if it's recording
#         if self._performance_part is not None:
#             from .performance import PerformancePart
#             assert isinstance(self._performance_part, PerformancePart)
#             pc = self.host_ensemble.host_session
#             length_factor = (1 if pc._recording_clock == "absolute" else pc._recording_clock.absolute_rate()) / \
#                             clock.absolute_rate()
#             recorded_length = tuple(x * length_factor for x in length) \
#                 if hasattr(length, "__len__") else length * length_factor
#             recorded_length_sum = sum(recorded_length) if hasattr(recorded_length, "__len__") else recorded_length
#
#             if isinstance(pitch, Envelope):
#                 pitch.normalize_to_duration(recorded_length_sum)
#             if isinstance(volume, Envelope):
#                 volume.normalize_to_duration(recorded_length_sum)
#             self._performance_part.new_note(pc.get_recording_beat(), recorded_length, pitch, volume, properties)
#
#         # now that we've notated the length, we collapse it if it's a tuple
#         length = sum(length) if hasattr(length, "__len__") else length
#
#         # apply explicit playback adjustments, as well as those implied by articulations and other notations
#         unaltered_length = length
#         pitch, volume, length = properties.apply_playback_adjustments(pitch, volume, length)
#
#         # Note that, even if there's a clock involved we run _do_play_note in a simple thread rather than a sub-clock.
#         # That is because the overhead of running in a clock is high for small sleep values like animation of pitch and
#         # volume, and it gets way behind. Better to just use a parallel Thread and adjust the length
#         if clock is not None:
#             if not clock.is_fast_forwarding():
#                 # note that if we're fast-forwarding we don't want to play the note
#                 # we do still want to call wait below to advance time (no sleeping will happen on the master clock)
#                 clock.fork_unsynchronized(process_function=self._do_play_note,
#                                           args=(pitch, volume, length / clock.absolute_rate(), properties, clock))
#             if blocking:
#                 clock.wait(unaltered_length)
#         else:
#             threading.Thread(target=self._do_play_note, args=(pitch, volume, length, properties)).start()
#             if blocking:
#                 time.sleep(unaltered_length)
#
#     def play_chord(self, pitches, volume, length, properties=None, blocking=True, clock=None):
#         """
#         Simple utility for playing chords without having to play notes with blocking=False
#         Takes a list of pitches, and passes them to play_note
#         """
#         assert hasattr(pitches, "__len__")
#
#         properties = self._convert_properties_to_dictionary(properties)
#
#         # we should either be given a number of noteheads equal to the number of pitches or just one notehead for all
#         assert len(properties.noteheads) == len(pitches) or len(properties.noteheads) == 1, \
#             "Wrong number of noteheads for chord."
#
#         for i, pitch in enumerate(pitches[:-1]):
#             # for all but the last pitch, play it without blocking, so we can start all the others
#             # also copy the properties dictionary, and pick out the correct notehead if we've been given several
#             properties_copy = deepcopy(properties)
#             if len(properties.noteheads) > 1:
#                 properties_copy.noteheads = [properties_copy.noteheads[i]]
#             self.play_note(pitch, volume, length, properties=properties_copy, blocking=False, clock=clock)
#
#         # for the last pitch, block or not based on the blocking parameter
#         # also, if we've been given a list of noteheads, pick out the last one
#         if len(properties.noteheads) > 1:
#             properties.noteheads = [properties.noteheads[-1]]
#         self.play_note(pitches[-1], volume, length, properties=properties, blocking=blocking, clock=clock)
#
#     def start_note(self, pitch, volume, properties=None):
#         """
#         Starts a note 'manually', meaning that its length is not predetermined, and that it has to be manually ended
#         later by calling 'end_note' or 'end_all_notes'
#         """
#         properties = self._convert_properties_to_dictionary(properties)
#         note_id = self._do_start_note(pitch, volume, properties)
#         self._notes_started.append((note_id, pitch, volume, self.time(), properties))
#         # returns the note_id as a reference, in case we want to change pitch mid-playback
#         return note_id
#
#     def end_note(self, note_id=None):
#         """
#         Ends the note with the given note id. If none is specified, it ends the note we started longest ago.
#         Note that this only applies to notes started in an open-ended way with 'start_note', notes created
#         using play_note have their lifecycle controlled automatically.
#         """
#         note_to_end = None
#         if note_id is not None:
#             # find the note referred to in the notes_started list
#             for started_note in self._notes_started:
#                 if started_note[0] == note_id:
#                     note_to_end = started_note
#                     break
#             if note_to_end is not None:
#                 self._notes_started.remove(note_to_end)
#         elif len(self._notes_started) > 0:
#             # if no note_id is specified, just end the note that has been going the longest
#             note_to_end = self._notes_started.pop(0)
#
#         if note_to_end is None:
#             # no appropriate note has been found to end
#             return
#
#         note_id, pitch, volume, start_time, properties = note_to_end
#         # call the specific implementation to stop the note
#         self._do_end_note(note_id)
#
#         # save to performance part if we're recording, and we have been since the note started
#         if self._performance_part is not None and start_time >= self.host_ensemble.host_session.recording_start_time:
#             self._performance_part.new_note(
#                 start_time - self.host_ensemble.host_session.recording_start_time,
#                 self.time() - start_time, pitch, volume, properties
#             )
#
#     def end_all_notes(self):
#         """
#         Ends all notes that have been manually started with 'start_note'
#         """
#         while len(self._notes_started) > 0:
#             self.end_note()
#
#     def num_notes_playing(self):
#         """
#         Returns the number of notes currently playing that were manually started with 'start_note'
#         """
#         return len(self._notes_started)
#
#     def __repr__(self):
#         return "ScampInstrument({}, {})".format(self.host_ensemble, self.name)
#
#
#
# class ScampInstrument:
#
#     def __init__(self):
#         self.banana = 5
#
#
# class SoundfontPlayer(PlaybackMethod):
#
#     def start_note(self):
#         note_id = super().start_note()
#         print("FluidSynth got note id", note_id)
#         return note_id
#
#
# class MIDIOutputStreamer(PlaybackMethod):
#
#     def start_note(self):
#         note_id = super().start_note()
#         print("MIDIOutputStreamer got note id", note_id)
#         return note_id
#
#
# class MIDIScampInstrument(MIDIOutputStreamer, SoundfontPlayer, ScampInstrument):
#
#     def __init__(self):
#         super().__init__()
#
#
# bob = MIDIScampInstrument()
#
# bob.start_note()
# print(bob.banana)