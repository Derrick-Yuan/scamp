import itertools
from .spelling import SpellingPolicy
from .note_properties import NotePropertiesDictionary
from clockblocks import *
import logging
import time
from typing import Union, Sequence
from numbers import Number


class NoteHandle:

    def __init__(self, note_id, instrument):
        self.note_id = note_id
        self.instrument: ScampInstrument = instrument

    def change_parameter(self, param_name, target_value_or_values: Union[Sequence, Number],
                         transition_length_or_lengths: Union[Sequence, Number] = 0,
                         transition_curve_shape_or_shapes: Union[Sequence, Number] = 0, clock="auto"):
        self.instrument.change_note_parameter(self.note_id, param_name, target_value_or_values,
                                              transition_length_or_lengths, transition_curve_shape_or_shapes, clock)

    def change_pitch(self, target_value_or_values: Union[Sequence, Number],
                     transition_length_or_lengths: Union[Sequence, Number] = 0,
                     transition_curve_shape_or_shapes: Union[Sequence, Number] = 0, clock="auto"):
        self.instrument.change_note_pitch(self.note_id, target_value_or_values, transition_length_or_lengths,
                                          transition_curve_shape_or_shapes, clock)

    def change_volume(self, target_value_or_values: Union[Sequence, Number],
                      transition_length_or_lengths: Union[Sequence, Number] = 0,
                      transition_curve_shape_or_shapes: Union[Sequence, Number] = 0, clock="auto"):
        self.instrument.change_note_volume(self.note_id, target_value_or_values, transition_length_or_lengths,
                                           transition_curve_shape_or_shapes, clock)

    def split(self, clock="auto"):
        self.instrument.split_note(self.note_id, clock)

    def end(self):
        self.instrument.end_note(self.note_id)


class PlaybackImplementer:

    _note_id_generator = itertools.count()

    def __init__(self):
        self._active_note_ids = []
        self._note_info_by_id = {}

    """
    ------------------------w------------ Playback Methods to be Overridden ----------------------------------------
    Mix-ins providing extra playback functionality should override these methods starting with:
        note_id = super().start_note(pitch, volume, properties)
    And ending with:
        return note_id
    This way, the note_id generated by the base class is passed up the chain to each piece of playback machinery.
    """

    def _do_start_note(self, pitch, volume, properties):
        # does the actual sonic implementation of starting a note and creates an id for it
        # this base class also maintains a list of active note ids and a dictionary of info about the notes
        note_id = next(PlaybackImplementer._note_id_generator)
        self._active_note_ids.append(note_id)
        self._note_info_by_id[note_id] = {
            "start_time": TimeStamp(),
            "end_time": None,
            "split_points": [],
            "parameter_start_values": {
                "pitch": pitch,
                "volume": volume,
            },
            "parameter_values": {
                "pitch": pitch,
                "volume": volume,
            },
            "parameter_change_segments": {},
            "properties": properties,
        }
        return note_id

    def _do_end_note(self, note_id):
        # Does the actual sonic implementation of ending a the note with the given id
        # this base class also removes the id from the list of active notes and deletes the info about it
        self._active_note_ids.remove(note_id)
        del self._note_info_by_id[note_id]
        return note_id

    def _do_change_note_pitch(self, note_id, new_pitch):
        # Changes the pitch of the note with the given id
        self._note_info_by_id[note_id]["parameter_values"]["pitch"] = new_pitch
        return note_id

    def _do_change_note_volume(self, note_id, new_volume):
        # Changes the expression of the note with the given id
        self._note_info_by_id[note_id]["parameter_values"]["volume"] = new_volume
        return note_id

    def _do_change_note_parameter(self, note_id, parameter_name, new_value):
        # Changes an arbitrary parameter of the note, for instance when controlling an electronic instrument over osc
        self._note_info_by_id[note_id]["parameter_values"][parameter_name] = new_value
        return note_id


class ParameterChangeSegment(EnvelopeSegment):

    def __init__(self, parameter_change_function, start_value, target_value, transition_length, transition_curve_shape,
                 clock, temporal_resolution=0.01):
        """
        Convenient class for handling interruptable transitions of parameter values and storing info on them
        :param parameter_change_function: since this is for general parameters, we pass the function to be called
        to set the parameter. Generally will call _do_change_note_parameter/pitch/volume for a given note_id
        :param start_value: start value of the parameter in the transition
        :param target_value: target value of the parameter in the transition
        :param transition_length: length of the transition in beats on the clock given
        :param transition_curve_shape: curve shape of the transition
        :param clock: the clock that all of this happens in reference to
        :param temporal_resolution: time resolution of the unsynchronized process. One of the following:
         - just a number (in seconds)
         - the string "pitch-based", in which case we derive it based on trying to get a smooth pitch change
         - the string "volume-based", in which case we derive it based on trying to get a smooth volume change.
        """
        # set this up as an envelope
        super().__init__(0, transition_length, start_value, target_value, transition_curve_shape)
        # "do_change_parameter" feels more like an action name
        self.do_change_parameter = parameter_change_function

        self.clock = clock  # the parent clock that this process runs on
        self._run_clock = None  # the sub-clock created by forking this process
        self.running = False  # flag used for aborting the unsynchronized process

        # some of the key data that this envelope holds onto are the time stamps at which it starts and finishes
        # this can be used to construct the appropriate envelope segment on whichever clock we're recording on
        self.start_time_stamp = None
        self.end_time_stamp = None
        self.temporal_resolution = temporal_resolution

    def run(self):
        """
        Runs the segment from start to finish, gradually changing the parameter.
        This function runs as a synchronized clock process (it should be forked), and it starts a parallel,
        unsynchronized process ("_animation_function") to do the actual calls to change parameter
        """
        self.start_time_stamp = TimeStamp(self.clock)

        if self.end_level == self.start_level:
            wait(self.duration)
            self.end_time_stamp = TimeStamp(self.clock)
            self.do_change_parameter(self.end_level)
            return

        # if this segment has no duration, no need to do any animation
        # just set it to the final value and return
        if self.duration == 0:
            self.end_time_stamp = TimeStamp(self.clock)
            self.do_change_parameter(self.end_level)
            return

        self.start_time_stamp = TimeStamp(self.clock)
        self.running = True  # used to kill the unsynchronized process when we abort or this synchronized one ends

        # we note down the clock we're running this on. If abort is called, this clock gets killed
        self._run_clock = current_clock()

        # determine the time increment, perhaps by calculating a good one for the given parameter
        if self.temporal_resolution == "pitch-based":
            time_increment = self._get_good_pitch_bend_temporal_resolution()
        elif self.temporal_resolution == "volume-based":
            time_increment = self._get_good_volume_temporal_resolution()
        else:
            time_increment = self.temporal_resolution
        # don't animate faster than 10ms though
        time_increment = max(0.01, time_increment)

        def _animation_function():
            # does the intermediate changing of values; since it's sleeping in small time increments, we fork it
            # as unsynchronized parallel process so that it doesn't gum up the clocks with the overhead of
            # waking and sleeping rapidly
            beats_passed = 0

            while beats_passed < self.duration and self.running:
                start = time.time()
                if beats_passed > 0:  # no need to change the parameter the first time, before we had a chance to wait
                    self.do_change_parameter(self.value_at(beats_passed))
                time.sleep(time_increment)
                # TODO: Absolute_rate would be great, except that it doesn't update between synchronized clock events
                # Is there a way of improving this??
                beats_passed += (time.time() - start) * self.clock.absolute_rate()

        # start the unsynchronized animation function
        self.clock.fork_unsynchronized(_animation_function)
        # waits in a synchronized fashion so that it can save an accurate time stamp at the end
        wait(self.duration)

        # we only get here if it wasn't aborted while running, since that will call kill on the child clock
        self.running = False
        self.end_time_stamp = TimeStamp(self.clock)
        self.do_change_parameter(self.end_level)

    def abort_if_running(self):
        if self.running:
            # if we were running, we save the time stamp at which we aborted as the end time stamp
            self.end_time_stamp = TimeStamp(self.clock)
            self._run_clock.kill()  # kill the clock doing the "run" function
            # since the units of this envelope are beats in self.clock, se how far we got in the envelope by
            # subtracting converting the start and end time stamps to those beats and subtracting
            how_far_we_got = self.end_time_stamp.time_in_clock(self.clock) - \
                             self.start_time_stamp.time_in_clock(self.clock)
            # now split there, discarding the rest of the envelope. This makes self.end_level the value we ended up at.
            if how_far_we_got < self.end_time:
                self.split_at(how_far_we_got)
            self.do_change_parameter(self.end_level)  # set it to where we should be at this point
        self.running = False  # this will make sure to abort the animation function

    def completed(self):
        # it's not running, but because it finished, not because it never started
        return not self.running and self.end_time_stamp is not None

    def _get_good_pitch_bend_temporal_resolution(self):
        """
        Returns a reasonable temporal resolution, based on this clock's envelope and rate, assuming it's a pitch curve
        """
        max_cents_per_second = self.max_absolute_slope() * 100 * self.clock.absolute_rate()
        # cents / update * updates / sec = cents / sec   =>  updates_freq = cents_per_second / cents_per_update
        # we'll aim for 4 cents per update, since some say the JND is 5-6 cents
        update_freq = max_cents_per_second / 4.0
        return 1 / update_freq

    def _get_good_volume_temporal_resolution(self):
        """
        Returns a reasonable temporal resolution, based on this clock's envelope and rate, assuming it's a volume curve
        """
        max_volume_per_second = self.max_absolute_slope() * self.clock.absolute_rate()
        # based on the idea that for midi volumes, it's quantized from 0 to 127, so there's not much point in updating
        # in between those quantization levels. It's a decent enough rule even if not using midi output.
        update_freq = max_volume_per_second * 127
        return 1 / update_freq

    def __repr__(self):
        return "ParameterChangeSegment[{}, {}, {}, {}, {}]".format(
            self.start_time_stamp, self.end_time_stamp, self.start_level, self.end_level, self.curve_shape
        )


class ScampInstrument(PlaybackImplementer):

    def __init__(self, name, ensemble=None):
        """
        Base instrument class.
        """
        self.name = name
        # used to help distinguish between identically named instruments in the same ensemble
        self.name_count = ensemble.get_part_name_count(self.name) if ensemble is not None else 0

        self.ensemble = ensemble
        self._transcribers_to_notify = []

        # A policy for spelling notes used as the default for this instrument. Overrides any broader defaults.
        self._default_spelling_policy = None

        super().__init__()

    """
    ------------------------------------------ "Meta" Playback Methods ------------------------------------------
    Playback methods that make use of the specific implementations defined and overridden above
    """

    def play_note(self, pitch, volume, length, properties=None, blocking=True, clock="auto"):
        properties = self._standardize_properties(properties)
        pitch = Envelope.from_list(pitch).normalize_to_duration(length) if hasattr(pitch, "__len__") else pitch
        volume = Envelope.from_list(volume).normalize_to_duration(length) if hasattr(volume, "__len__") else volume

        clock = current_clock() if clock == "auto" else clock
        if clock is None:
            clock = Clock()

        start_pitch = pitch.start_level() if isinstance(pitch, Envelope) else pitch
        start_volume = volume.start_level() if isinstance(volume, Envelope) else volume

        # ISSUE: playback (esp. length) adjustments, staccato

        # if a silent flag is set, just call PlaybackImplementer._do_start_note(self, etc) instead of super()
        # if we want playback only and no notation, put "do_not_notate" in properties["temp"]

        note_handle = self.start_note(start_pitch, start_volume, properties)
        if isinstance(pitch, Envelope):
            note_handle.change_pitch(pitch.levels[1:], pitch.durations, pitch.curve_shapes, clock)
        if isinstance(volume, Envelope):
            note_handle.change_volume(volume.levels[1:], volume.durations, volume.curve_shapes, clock)
        for param, value in properties.iterate_extra_parameters_and_values():
            if isinstance(value, Envelope):
                normalized_value = value.normalize_to_duration(length)
                note_handle.change_parameter(param, normalized_value.levels[1:], normalized_value.durations,
                                             normalized_value.curve_shapes, clock)
            else:
                note_handle.change_parameter(param, value)

    def start_note(self, pitch, volume, properties=None):
        properties = self._standardize_properties(properties)
        if "silent" in properties["temp"]:
            return NoteHandle(PlaybackImplementer._do_start_note(self, pitch, volume, properties), self)
        else:
            return NoteHandle(self._do_start_note(pitch, volume, properties), self)

    def start_chord(self):
        # Should return a chord handle, that's maybe a wrapper around a list of note handles?
        pass

    def _standardize_properties(self, raw_properties) -> NotePropertiesDictionary:
        """
        Turns the properties given into the standard form of a NotePropertiesDictionary
        :param raw_properties: can be None, a string, a list, or a dict
        :return: a NotePropertiesDictionary
        """
        properties = NotePropertiesDictionary.from_unknown_format(raw_properties) \
            if not isinstance(raw_properties, NotePropertiesDictionary) else raw_properties

        # resolve the spelling policy based on defaults (local first, then more global)
        if properties["spelling_policy"] is None:
            # if the note doesn't say how to be spelled, check the instrument
            if self.default_spelling_policy is not None:
                properties.spelling_policy = self.default_spelling_policy
            # if the instrument doesn't have a default spelling policy check the host (probably a Session)
            elif self.ensemble is not None and hasattr(self.ensemble, "default_spelling_property") and \
                    self.ensemble.default_spelling_policy is not None:
                properties.spelling_policy = self.default_spelling_policy
            # if the host doesn't have a default, then don't do anything and it will fall back to playback_settings
        return properties

    def change_note_parameter(self, note_id, param_name, target_value_or_values: Union[Sequence, Number],
                              transition_length_or_lengths: Union[Sequence, Number] = 0,
                              transition_curve_shape_or_shapes: Union[Sequence, Number] = 0, clock="auto"):
        """
        Changes the value of parameter of note playback over a given time; can also take a sequence of targets and times
        :param note_id: which note to affect
        :param param_name: name of the parameter to affect. "pitch" and "volume" are special cases
        :param target_value_or_values: target value (or list thereof) for the parameter
        :param transition_length_or_lengths: transition time(s) in beats to the target value(s)
        :param transition_curve_shape_or_shapes: curve shape(s) for the transition(s)
        :param clock: which clock all of this happens on, "auto" captures the clock from context
        """
        note_id = note_id.note_id if isinstance(note_id, NoteHandle) else note_id
        note_info = self._note_info_by_id[note_id]

        # which function do we use to actually carry out the change of parameter? Pitch and volume are special.
        if param_name == "pitch":
            def parameter_change_function(value): self._do_change_note_pitch(note_id, value)
            temporal_resolution = "pitch-based"
        elif param_name == "volume":
            def parameter_change_function(value): self._do_change_note_volume(note_id, value)
            temporal_resolution = "volume-based"
        else:
            def parameter_change_function(value): self._do_change_note_parameter(note_id, param_name, value)
            temporal_resolution = 0.01

        clock = current_clock() if clock == "auto" else clock
        if clock is None:
            clock = Clock()

        assert param_name in note_info["parameter_values"], \
            "Cannot change parameter {}, as it was undefined at note start.".format(param_name)

        if param_name in note_info["parameter_change_segments"]:
            segments_list = note_info["parameter_change_segments"][param_name]
        else:
            segments_list = note_info["parameter_change_segments"][param_name] = []

        # if there was a previous segment changing this same parameter, and it's not done yet, we should abort it
        if len(segments_list) > 0:
            segments_list[-1].abort_if_running()

        if hasattr(target_value_or_values, "__len__"):
            # assume linear segments unless otherwise specified
            transition_curve_shape_or_shapes = [0] * len(target_value_or_values) if \
                transition_curve_shape_or_shapes == 0 else transition_curve_shape_or_shapes
            assert hasattr(transition_length_or_lengths, "__len__") and \
                   hasattr(transition_curve_shape_or_shapes, "__len__")
            assert len(target_value_or_values) == len(transition_length_or_lengths) == \
                   len(transition_curve_shape_or_shapes), \
                "The list of target values must be accompanied by a equal length list of transition lengths and shapes."

            def do_animation_sequence():
                for target, length, shape in zip(target_value_or_values, transition_length_or_lengths,
                                                 transition_curve_shape_or_shapes):
                    this_segment = ParameterChangeSegment(
                        parameter_change_function, note_info["parameter_values"][param_name], target,
                        length, shape, clock, temporal_resolution=temporal_resolution)
                    segments_list.append(this_segment)
                    # note that these segments are not forked individually: they are chained together and called
                    # directly on a function (do_animation_sequence) that is forked. This means that when we abort
                    # one of them, we kill the clock that do_animation_sequence is running on, thereby aborting all
                    # remaining segments as well. This is exactly what we want: if we call change_note_parameter while
                    # previous change_note_parameter is running, we want to abort all segments of the one that's running
                    this_segment.run()

            clock.fork(do_animation_sequence)
        else:
            parameter_change_segment = ParameterChangeSegment(
                parameter_change_function, note_info["parameter_values"][param_name], target_value_or_values,
                transition_length_or_lengths, transition_curve_shape_or_shapes, clock,
                temporal_resolution=temporal_resolution)
            segments_list.append(parameter_change_segment)
            clock.fork(parameter_change_segment.run)

    def change_note_pitch(self, note_id, target_value_or_values: Union[Sequence, Number],
                          transition_length_or_lengths: Union[Sequence, Number] = 0,
                          transition_curve_shape_or_shapes: Union[Sequence, Number] = 0, clock="auto"):
        self.change_note_parameter(note_id, "pitch", target_value_or_values, transition_length_or_lengths,
                                   transition_curve_shape_or_shapes, clock)

    def change_note_volume(self, note_id, target_value_or_values: Union[Sequence, Number],
                           transition_length_or_lengths: Union[Sequence, Number] = 0,
                           transition_curve_shape_or_shapes: Union[Sequence, Number] = 0, clock="auto"):
        self.change_note_parameter(note_id, "volume", target_value_or_values, transition_length_or_lengths,
                                   transition_curve_shape_or_shapes, clock)

    def split_note(self, note_id, clock="auto"):
        """
        Adds a split point in a note, causing it later to be rendered as tied pieces.
        :param note_id: Which note or NoteHandle to split
        :param clock: Probably shouldn't ever need to mess with this. The clock is used to generate a TimeStamp, so
        all clocks in the same family will lead to the same result.
        """
        clock = current_clock() if clock == "auto" else clock
        if clock is None:
            clock = Clock()

        note_id = note_id.note_id if isinstance(note_id, NoteHandle) else note_id
        note_info = self._note_info_by_id[note_id]
        note_info["split_points"].append(TimeStamp(clock))

    def end_note(self, note_id: Union[int, NoteHandle] = None, clock="auto"):
        """
        Ends the note with the given note id. If none is specified, it ends the note we started longest ago.
        Note that this only applies to notes started in an open-ended way with 'start_note', notes created
        using play_note have their lifecycle controlled automatically.
        """
        clock = current_clock() if clock == "auto" else clock
        if clock is None:
            clock = Clock()

        # in case we're passed a NoteHandle instead of an actual id number, get the number from the handle
        note_id = note_id.note_id if isinstance(note_id, NoteHandle) else note_id

        if note_id is not None:
            # as specific note_id has been given, so it had better belong to a currently playing note!
            if note_id not in self._active_note_ids:
                logging.warning("Tried to end a note that was never started!")
                return
        elif len(self._active_note_ids) > 0:
            # no specific id was given, so end the oldest note
            note_id = self._active_note_ids[0]
        else:
            logging.warning("Tried to end a note that was never started!")
            return

        # end any segments that are still changing
        note_info = self._note_info_by_id[note_id]
        for param_name in note_info["parameter_change_segments"]:
            if len(note_info["parameter_change_segments"][param_name]) > 0:
                note_info["parameter_change_segments"][param_name][-1].abort_if_running()

        note_info["end_time"] = TimeStamp(clock)
        for transcriber in self._transcribers_to_notify:
            transcriber.register_note(self, note_info)

        self._do_end_note(note_id)

    def end_all_notes(self):
        """
        Ends all notes currently playing
        """
        while len(self._active_note_ids) > 0:
            self.end_note()

    def num_notes_playing(self):
        """
        Returns the number of notes currently playing.
        """
        return len(self._active_note_ids)

    """
    ------------------------------------------------- Other -----------------------------------------------------
    """

    @property
    def default_spelling_policy(self):
        return self._default_spelling_policy

    @default_spelling_policy.setter
    def default_spelling_policy(self, value):
        if value is None or isinstance(value, SpellingPolicy):
            self._default_spelling_policy = value
        elif isinstance(value, str):
            self._default_spelling_policy = SpellingPolicy.from_string(value)
        else:
            raise ValueError("Spelling policy not understood.")


class MidiPlaybackImplementer(PlaybackImplementer):

    def _do_start_note(self, pitch, volume, properties):
        note_id = super()._do_start_note(pitch, volume, properties)
        print("Starting Note", note_id, pitch, volume)
        return note_id

    def _do_end_note(self, note_id):
        note_id = super()._do_end_note(note_id)
        print("Ending Note", note_id)
        return note_id

    def _do_change_note_pitch(self, note_id, new_pitch):
        note_id = super()._do_change_note_pitch(note_id, new_pitch)
        print("Changing Pitch", note_id, new_pitch)
        return note_id

    def _do_change_note_volume(self, note_id, new_volume):
        note_id = super()._do_change_note_volume(note_id, new_volume)
        print("Changing Volume", note_id, new_volume)
        return note_id

    def _do_change_note_parameter(self, note_id, parameter_name, new_value):
        note_id = super()._do_change_note_parameter(note_id, parameter_name, new_value)
        print("Changing Parameter", note_id, parameter_name, new_value)
        return note_id


class MIDIScampInstrument(MidiPlaybackImplementer, ScampInstrument):
    pass

# class ScampInstrument(PlaybackMethod, SavesToJSON):
#
#     def __init__(self, host=None, name=None):
#         """
#         ScampInstrument inherits from PlaybackMethod, with the default
#         :param host: The Session or Ensemble that this instrument acts within
#         :param name: The name of this instrument (used later in labeling parts in output)
#         """
#         self.name = name
#         self.name_count = None  # if an ensemble
#         self.host_ensemble = None
#
#         if host is not None:
#             self.set_host(host)
#
#         # A policy for spelling notes used as the default for this instrument. Overrides the session default.
#         self._default_spelling_policy = None
#
#         # used to identify instruments uniquely, even if they're given the same name
#         self._notes_started = []   # each entry goes (note_id, pitch, volume, start_time, variant_dictionary)
#         self._performance_part = None
#
#     def set_host(self, host):
#         from .session import Session
#         from .ensemble import Ensemble
#         assert isinstance(host, (Session, Ensemble)), "ScampInstrument must be hosted by Ensemble or Session"
#         if isinstance(host, Session):
#             self.host_ensemble = host.ensemble
#         else:
#             self.host_ensemble = host
#         self.name_count = self.host_ensemble.get_part_name_count(self.name)
#
#     def time(self):
#         if self.host_ensemble is not None and self.host_ensemble.host_session is not None:
#             return self.host_ensemble.host_session.time()
#         else:
#             return time.time()
#
#
#     # ------------------ Methods to be implemented by subclasses ------------------
#
#     def _do_start_note(self, pitch, volume, properties):
#         # Does the actual sonic implementation of starting a note
#         # should return the note_id, which is used to keep track of the note
#         pass
#
#     def _do_end_note(self, note_id):
#         # Does the actual sonic implementation of ending a the note with the given id
#         pass
#
#     def change_note_pitch(self, note_id, new_pitch):
#         # Changes the pitch of the note with the given id
#         pass
#
#     def change_note_volume(self, note_id, new_volume):
#         # Changes the expression of the note with the given id
#         pass
#
#     def to_json(self):
#         return {
#             "type": "ScampInstrument",
#             "name": self.name,
#         }
#
#     # -------------- Reconstruct from JSON (doesn't need subclass reimplementation) ---------------
#
#     @staticmethod
#     def from_json(json_dict, host_ensemble=None):
#         # the 'type' argument of the json_dict tells us which kind of ScampInstrument constructor to use
#         type_to_create = None
#         for instrument_type in ScampInstrument.__subclasses__():
#             if json_dict["type"] == instrument_type.__name__:
#                 type_to_create = instrument_type
#                 break
#         if type_to_create is None:
#             raise ValueError("Trying to reconstruct instrument of type {}, "
#                              "but that type is not defined.".format(json_dict["type"]))
#         kwargs = dict(json_dict)
#         del kwargs["type"]
#         return type_to_create(host_ensemble, **kwargs)
#
#     # ------------------------- "Private" Playback Methods -----------------------
#
#     def _convert_properties_to_dictionary(self, raw_properties):
#         properties = NotePropertiesDictionary.from_unknown_format(raw_properties) \
#             if not isinstance(raw_properties, NotePropertiesDictionary) else raw_properties
#         if properties["spelling_policy"] is None:
#             if self.default_spelling_policy is not None:
#                 properties.spelling_policy = self.default_spelling_policy
#             elif self.host_ensemble is not None and self.host_ensemble.host_session is not None \
#                     and self.host_ensemble.host_session.default_spelling_policy is not None:
#                 properties.spelling_policy = self.host_ensemble.host_session.default_spelling_policy
#         return properties
#
#     def _do_play_note(self, pitch, volume, length, properties, clock=None):
#         # Does the actual sonic implementation of playing a note; used as a thread by the public method "play_note"
#         note_start_time = time.time()
#         # convert lists to Envelopes
#         is_animating_volume = isinstance(volume, Envelope)
#         is_animating_pitch = isinstance(pitch, Envelope)
#         # the starting volume (velocity) of the note needs to be as loud as the note is ever going to get
#         start_volume = volume.max_level() if isinstance(volume, Envelope) else volume
#         # the starting pitch should just be whatever it is
#         start_pitch = pitch.value_at(0) if isinstance(pitch, Envelope) else pitch
#
#         note_id = self._do_start_note(start_pitch, start_volume, properties)
#         if is_animating_volume or is_animating_pitch:
#             temporal_resolution = float("inf")
#             if is_animating_volume:
#                 volume_curve = volume.normalize_to_duration(length, False)
#                 temporal_resolution = min(temporal_resolution,
#                                           ScampInstrument.get_good_volume_temporal_resolution(volume_curve))
#             if is_animating_pitch:
#                 pitch_curve = pitch.normalize_to_duration(length, False)
#                 temporal_resolution = min(temporal_resolution,
#                                           ScampInstrument.get_good_pitch_bend_temporal_resolution(pitch_curve))
#             temporal_resolution = max(temporal_resolution, 0.01)  # faster than this is wasteful, doesn't seem to help
#
#             def animate_pitch_and_volume():
#                 while note_start_time is not None:
#                     try:
#                         # Sometimes do_play_note ends and start_time gets set to None in the middle of
#                         # the while loop, leading to a TypeError when we do time.time() - note_start_time
#                         # this catches that possibility
#                         if is_animating_volume:
#                             # note that, since change_note_volume is affecting expression values, we need to send it
#                             # the proportion of the start_volume rather than the absolute volume
#                             self.change_note_volume(note_id,
#                                                     volume_curve.value_at(time.time() - note_start_time) / start_volume)
#                         if is_animating_pitch:
#                             self.change_note_pitch(note_id, pitch_curve.value_at(time.time() - note_start_time))
#                     except TypeError:
#                         break
#
#                     time.sleep(temporal_resolution)
#
#             if temporal_resolution < length:  # catches the case of a static curve with infinite temporal_resolution
#                 if clock is not None:
#                     clock.fork_unsynchronized(process_function=animate_pitch_and_volume)
#                 else:
#                     threading.Thread(target=animate_pitch_and_volume, daemon=True).start()
#
#         time.sleep(length)
#         # cut off any pitch or volume animation thread by setting the start_time to None
#         note_start_time = None
#
#         self._do_end_note(note_id)
#
#     @staticmethod
#     def get_good_pitch_bend_temporal_resolution(pitch_envelope):
#         """
#         Returns a reasonable temporal resolution
#         :type pitch_envelope: Envelope
#         """
#         max_cents_per_second = pitch_envelope.max_absolute_slope() * 100
#         # cents / update * updates / sec = cents / sec   =>  updates_freq = cents_per_second / cents_per_update
#         # we'll aim for 4 cents per update, since some say the JND is 5-6 cents
#         update_freq = max_cents_per_second / 4.0
#         return 1 / update_freq
#
#     @staticmethod
#     def get_good_volume_temporal_resolution(volume_envelope):
#         """
#         Returns a reasonable temporal resolution
#         :type volume_envelope: Envelope
#         """
#         max_volume_per_second = volume_envelope.max_absolute_slope()
#         # no point in updating faster than the number of ticks per second
#         update_freq = max_volume_per_second * 127
#         return 1 / update_freq
#
#     # ------------------------- "Public" Playback Methods -------------------------
#
#     def play_note(self, pitch, volume, length, properties=None, blocking=True, clock=None):
#         """
#         Play a note
#         :param pitch: The midi pitch of the note. Can be floating-point, can be a list or Envelope.
#         :param volume: The volume, in a normalized range 0 to 1. Can be a list or Envelope.
#         :param length: The length of the note with respect to the clock used (seconds if no clock is used).
#         :param properties: A dictionary of properties about this note
#         :param blocking: blocks the current thread until done playing
#         :param clock: The clock within which this note is played. If none, we check if a clock has been defined on this
#         thread by setting threading.current_thread().__clock__ and use that. If no clocks at all, uses seconds.
#         :return: None
#         """
#
#         if clock is None and hasattr(threading.current_thread(), "__clock__"):
#             clock = threading.current_thread().__clock__
#
#         properties = self._convert_properties_to_dictionary(properties)
#
#         volume = Envelope.from_list(volume) if hasattr(volume, "__len__") else volume
#         pitch = Envelope.from_list(pitch) if hasattr(pitch, "__len__") else pitch
#
#         # record the note in the hosting session, if it's recording
#         if self._performance_part is not None:
#             from .performance import PerformancePart
#             assert isinstance(self._performance_part, PerformancePart)
#             pc = self.host_ensemble.host_session
#             length_factor = (1 if pc._recording_clock == "absolute" else pc._recording_clock.absolute_rate()) / \
#                             clock.absolute_rate()
#             recorded_length = tuple(x * length_factor for x in length) \
#                 if hasattr(length, "__len__") else length * length_factor
#             recorded_length_sum = sum(recorded_length) if hasattr(recorded_length, "__len__") else recorded_length
#
#             if isinstance(pitch, Envelope):
#                 pitch.normalize_to_duration(recorded_length_sum)
#             if isinstance(volume, Envelope):
#                 volume.normalize_to_duration(recorded_length_sum)
#             self._performance_part.new_note(pc.get_recording_beat(), recorded_length, pitch, volume, properties)
#
#         # now that we've notated the length, we collapse it if it's a tuple
#         length = sum(length) if hasattr(length, "__len__") else length
#
#         # apply explicit playback adjustments, as well as those implied by articulations and other notations
#         unaltered_length = length
#         pitch, volume, length = properties.apply_playback_adjustments(pitch, volume, length)
#
#         # Note that, even if there's a clock involved we run _do_play_note in a simple thread rather than a sub-clock.
#         # That is because the overhead of running in a clock is high for small sleep values like animation of pitch and
#         # volume, and it gets way behind. Better to just use a parallel Thread and adjust the length
#         if clock is not None:
#             if not clock.is_fast_forwarding():
#                 # note that if we're fast-forwarding we don't want to play the note
#                 # we do still want to call wait below to advance time (no sleeping will happen on the master clock)
#                 clock.fork_unsynchronized(process_function=self._do_play_note,
#                                           args=(pitch, volume, length / clock.absolute_rate(), properties, clock))
#             if blocking:
#                 clock.wait(unaltered_length)
#         else:
#             threading.Thread(target=self._do_play_note, args=(pitch, volume, length, properties)).start()
#             if blocking:
#                 time.sleep(unaltered_length)
#
#     def play_chord(self, pitches, volume, length, properties=None, blocking=True, clock=None):
#         """
#         Simple utility for playing chords without having to play notes with blocking=False
#         Takes a list of pitches, and passes them to play_note
#         """
#         assert hasattr(pitches, "__len__")
#
#         properties = self._convert_properties_to_dictionary(properties)
#
#         # we should either be given a number of noteheads equal to the number of pitches or just one notehead for all
#         assert len(properties.noteheads) == len(pitches) or len(properties.noteheads) == 1, \
#             "Wrong number of noteheads for chord."
#
#         for i, pitch in enumerate(pitches[:-1]):
#             # for all but the last pitch, play it without blocking, so we can start all the others
#             # also copy the properties dictionary, and pick out the correct notehead if we've been given several
#             properties_copy = deepcopy(properties)
#             if len(properties.noteheads) > 1:
#                 properties_copy.noteheads = [properties_copy.noteheads[i]]
#             self.play_note(pitch, volume, length, properties=properties_copy, blocking=False, clock=clock)
#
#         # for the last pitch, block or not based on the blocking parameter
#         # also, if we've been given a list of noteheads, pick out the last one
#         if len(properties.noteheads) > 1:
#             properties.noteheads = [properties.noteheads[-1]]
#         self.play_note(pitches[-1], volume, length, properties=properties, blocking=blocking, clock=clock)
#
#     def start_note(self, pitch, volume, properties=None):
#         """
#         Starts a note 'manually', meaning that its length is not predetermined, and that it has to be manually ended
#         later by calling 'end_note' or 'end_all_notes'
#         """
#         properties = self._convert_properties_to_dictionary(properties)
#         note_id = self._do_start_note(pitch, volume, properties)
#         self._notes_started.append((note_id, pitch, volume, self.time(), properties))
#         # returns the note_id as a reference, in case we want to change pitch mid-playback
#         return note_id
#
#     def end_note(self, note_id=None):
#         """
#         Ends the note with the given note id. If none is specified, it ends the note we started longest ago.
#         Note that this only applies to notes started in an open-ended way with 'start_note', notes created
#         using play_note have their lifecycle controlled automatically.
#         """
#         note_to_end = None
#         if note_id is not None:
#             # find the note referred to in the notes_started list
#             for started_note in self._notes_started:
#                 if started_note[0] == note_id:
#                     note_to_end = started_note
#                     break
#             if note_to_end is not None:
#                 self._notes_started.remove(note_to_end)
#         elif len(self._notes_started) > 0:
#             # if no note_id is specified, just end the note that has been going the longest
#             note_to_end = self._notes_started.pop(0)
#
#         if note_to_end is None:
#             # no appropriate note has been found to end
#             return
#
#         note_id, pitch, volume, start_time, properties = note_to_end
#         # call the specific implementation to stop the note
#         self._do_end_note(note_id)
#
#         # save to performance part if we're recording, and we have been since the note started
#         if self._performance_part is not None and start_time >= self.host_ensemble.host_session.recording_start_time:
#             self._performance_part.new_note(
#                 start_time - self.host_ensemble.host_session.recording_start_time,
#                 self.time() - start_time, pitch, volume, properties
#             )
#
#     def end_all_notes(self):
#         """
#         Ends all notes that have been manually started with 'start_note'
#         """
#         while len(self._notes_started) > 0:
#             self.end_note()
#
#     def num_notes_playing(self):
#         """
#         Returns the number of notes currently playing that were manually started with 'start_note'
#         """
#         return len(self._notes_started)
#
#     def __repr__(self):
#         return "ScampInstrument({}, {})".format(self.host_ensemble, self.name)
#
#
#
# class ScampInstrument:
#
#     def __init__(self):
#         self.banana = 5
#
#
# class SoundfontPlayer(PlaybackMethod):
#
#     def start_note(self):
#         note_id = super().start_note()
#         print("FluidSynth got note id", note_id)
#         return note_id
#
#
# class MIDIOutputStreamer(PlaybackMethod):
#
#     def start_note(self):
#         note_id = super().start_note()
#         print("MIDIOutputStreamer got note id", note_id)
#         return note_id
#
#
# class MIDIScampInstrument(MIDIOutputStreamer, SoundfontPlayer, ScampInstrument):
#
#     def __init__(self):
#         super().__init__()
#
#
# bob = MIDIScampInstrument()
#
# bob.start_note()
# print(bob.banana)